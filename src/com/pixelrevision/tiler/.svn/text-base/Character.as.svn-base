package com.pixelrevision.tiler {		import flash.display.Sprite;		import flash.geom.Rectangle;	import flash.geom.Matrix;		import flash.net.URLRequest;	import flash.display.Loader;		import flash.events.Event;	import flash.events.ProgressEvent;		import com.pixelrevision.tiler.*;			public class Character extends TilerSprite{				protected var _sprite:Sprite;				protected var _map:Map;				protected var _tileWidth:Number;		protected var _tileHeight:Number;				protected var _xPos:Number;		protected var _yPos:Number;				protected var _mapCollisions:Boolean;		protected var _mapCollisionsResolve:Boolean;								/**		 *	@constructor		 *	@param	tileWidth	The amount of pixels the character takes up.		 *	@param	tileHeight	The amount of pixels the character takes up.		 *	@param	mapCollisions	If map collisions should be checked or not.		 */		public function Character(tileWidth:Number = 16, tileHeight:Number = 16, mapCollisions:Boolean = true){			super();						_tileWidth = tileWidth;			_tileHeight = tileHeight;						_sprite = new Sprite();			_sprite.graphics.beginFill(0xCCCCCC, .75);			_sprite.graphics.lineStyle(1, 0x999999);			_sprite.graphics.drawRect(0, 0, _tileWidth, _tileHeight);			_sprite.graphics.endFill();						_mapCollisions = mapCollisions;			_mapCollisionsResolve = true;						_xPos = 0;			_yPos = 0;						addEventListener("AddedToTiler", onQuadrantChange);					}				/**		 * Sets the x position.  If collision detection with the map is on than it gets applied.			 */			override public function set x(value:Number):void{			if(_map != null && _mapCollisions){				checkCollisionWithMap(value, y);			}else{				super.x = value;			}		}				/**		 * Sets the y position.  If collision detection with the map is on than it gets applied.			 */		override public function set y(value:Number):void{			if(_map != null && _mapCollisions){				checkCollisionWithMap(x, value);			}else{				super.y = value;			}		}						/**		 * The width of the bounding box			 */		public function set tileWidth(value:Number):void{			_tileWidth = value;		}		public function get tileWidth():Number{			return _tileWidth;		}				/**		 * The height of the bounding box			 */		public function set tileHeight(value:Number):void{			_tileHeight = value;		}		public function get tileHeight():Number{			return _tileHeight;		}				/**		 * The sprite to use when drawing.			 */		public function set sprite(value:Sprite):void{			_sprite.graphics.clear();			_sprite = value;		}		public function get sprite():Sprite{			return _sprite;		}				protected function checkCollisionWithMap(checkX:Number, checkY:Number):void{			// find corner points			var rightX:uint = Math.floor(  (checkX + _tileWidth)/_map.tileWidth  );			var leftX:uint = Math.floor( checkX/_map.tileWidth );			var botY:uint = Math.floor(  ( checkY + _tileHeight)/_map.tileHeight );			var topY:uint = Math.floor( checkY/_map.tileHeight);						// check if they are walls			var upRight:uint = _map.data[topY][rightX];			var upLeft:uint = _map.data[topY][leftX];			var botRight:uint = _map.data[botY][rightX];			var botLeft:uint = _map.data[botY][leftX];									// check if the width or height is larger that the tiles			var right:Boolean = true;			var left:Boolean = true;			var top:Boolean = true;			var bot:Boolean = true;						// if the height is bigger check the middle parts			var extras:uint;			var tempCheck:uint;			var i:uint;			if(_tileHeight > _map.tileHeight){				extras = Math.ceil(_tileHeight/_map.tileHeight);				for(i=1; i<extras; i++){					tempCheck = _map.data[topY+i][rightX];					if(!_map.tiles[tempCheck].walkable){						right = false;					}					tempCheck = _map.data[topY+i][leftX];					if(!_map.tiles[tempCheck].walkable){						left = false;					}				}			}			// if the width is bigger check the middle parts			if(_tileWidth > _map.tileWidth){				extras = Math.ceil(_tileWidth/_map.tileWidth);				for(i=1; i<extras; i++){					tempCheck = _map.data[topY][leftX+i];					if(!_map.tiles[tempCheck].walkable){						top = false;					}					tempCheck = _map.data[botY][leftX+i];					if(!_map.tiles[tempCheck].walkable){						bot = false;					}				}			}						var event:TilerEvent;									var nextStepY:Number = checkY;			// check the y position			if(checkY > _y){				if(!_map.tiles[botRight].walkable || !_map.tiles[botLeft].walkable || !bot){					// collide so move up					if(_mapCollisionsResolve){						nextStepY = ((botY * _map.tileHeight) - _tileHeight) -.25;					}					// now broadcast an event notifying that the map has been collided with					event = new TilerEvent("CollidedWithMap");					event.info.character = this;					event.info.direction = "bottom";					dispatchEvent( event );				}			}else if(checkY < _y){				if(!_map.tiles[upRight].walkable || !_map.tiles[upLeft].walkable || !top){					// collide so move back					if(_mapCollisionsResolve){						nextStepY = ( (topY+1)*_map.tileHeight ) + .25;					}					// now broadcast an event notifying that the map has been collided with					event = new TilerEvent("CollidedWithMap");					event.info.character = this;					event.info.direction = "top";					dispatchEvent( event );				}			}			_y = nextStepY;						// now check the x position			var nextStepX:Number = checkX;			if(checkX > _x){				if(!_map.tiles[botRight].walkable || !_map.tiles[upRight].walkable || !right){					// collide so move left					if(_mapCollisionsResolve){						nextStepX = ((rightX * _map.tileWidth) - _tileWidth) -.25;					}					// now broadcast an event notifying that the map has been collided with					event = new TilerEvent("CollidedWithMap");					event.info.character = this;					event.info.direction = "right";					dispatchEvent( event );				}			}else if(checkX < _x){				if(!_map.tiles[upLeft].walkable || !_map.tiles[botLeft].walkable || !left){					// collide so move back					if(_mapCollisionsResolve){						nextStepX = ( (leftX+1)*_map.tileWidth ) + .25;					}					// now broadcast an event notifying that the map has been collided with					event = new TilerEvent("CollidedWithMap");					event.info.character = this;					event.info.direction = "left";					dispatchEvent( event );				}			}			_x = nextStepX;		}						/**		 * Performs basic collision detection with 2 characters.		 */		public function checkCollisionWithCharacter(character:Character):Boolean{			var rect1:Rectangle = new Rectangle(x, y, tileWidth, tileHeight);			var rect2:Rectangle = new Rectangle(character.x, character.y, character.tileWidth, character.tileHeight);			if( rect1.intersects(rect2) ){				var event:TilerEvent = new TilerEvent("CollidedWithCharacter");				event.info.character = this;				event.info.characterCollidedWith = character;				dispatchEvent( event );				return true;			}			return false;		}				/**		 * The map to check collisions with.		 */		public function set map(value:Map):void{			_map = value;		}		public function get map():Map{			return _map;		}				/**		 * Renders the character sprite on the main draw board.		 */		override public function draw(tiler:Tiler):void{			// create an offset			var offsetMatrix:Matrix = new Matrix();			offsetMatrix.tx = x  -tiler.camera.x + (tiler.width/2);			offsetMatrix.ty = y - tiler.camera.y + (tiler.height/2);			// redraw the bitmap			tiler.drawBoard.draw(_sprite, offsetMatrix);		}								override protected function onQuadrantChange(e:TilerEvent):void{			var quadrantBounds:Object = e.info.tiler.quadrantBounds;			if(x > quadrantBounds.xMin && x < quadrantBounds.xMax){				if(y > quadrantBounds.yMin && y < quadrantBounds.yMax){					flaggedForDrawing = true;					flaggedForUpdates = true;				}			}else{				flaggedForDrawing = false;				flaggedForUpdates = false;			}			// check if I'm in the current quadrant and add me to the render/update lists if I am		}													}}