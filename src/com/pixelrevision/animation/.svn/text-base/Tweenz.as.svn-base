package com.pixelrevision.animation{		import flash.utils.getTimer;	import flash.display.*;	import flash.events.*;			/**	 *	 * @class Tweenz	 * @description Light weight easing class with all the equations.	 * @author pixelrevision	 * @version .5	 * 	 */	public class Tweenz{				private static var _controller;		private static var _initialized:Boolean = false;		private static var tweenElements:Array  = new Array();		private static var _prevTime:Number;		public static var events:EventDispatcher;								/**		 * Initializes		 */		public static function init(){			_prevTime = getTimer();			_controller = new Sprite();			_controller.addEventListener(Event.ENTER_FRAME, Tweenz.processTweens);			_initialized = true;			events = new EventDispatcher();		}			/**		* Tween a property of an object		 *		 * @param	object		The object referenced		 * @param	prop		The property of the object to tween.  Needs to be a number.		 * @param	propDest		The destination value.		 * @param	timeSeconds		The duration of the tween in seconds.		 * @param	animType		The transition to use.		 * @param	delay		How long to wait before applying the transition.		 * @param	callback		A callback function.  Applied from the scope of the tween object by default.		 */		public static function tween(object, prop, propDest, timeSeconds:Number, animType:String="easeoutexpo", delay:Number=0, callback = null, extra1 = 0, extra2 = 0):void{			var i;						if(!_initialized){				init();			}			// look for an array of properties			var _props:Array = new Array();			if (typeof(prop) == "string"){				_props[0] = prop;			}else{				_props = prop;			}						// look for an array of property destinations			if(typeof(propDest) == "number"){				var _propDests = new Array();				for(i=0; i<_props.length; i++){					_propDests[i] = propDest;				}			}else{				_propDests = propDest;			}			var currentTime = getTimer();			// insert a new tween			for(i in _props){				var currentProp = _props[i];				var currentPropDest = _propDests[i];				var base = tweenElements.length;				tweenElements[base] = new Array();				tweenElements[base]["object"] = object;				tweenElements[base]["prop"] = currentProp;				tweenElements[base]["propDest"] = currentPropDest;				tweenElements[base]["startTime"] = currentTime + (delay*1000);				tweenElements[base]["endTime"] = tweenElements[base]["startTime"] + (timeSeconds*1000);				tweenElements[base]["animType"] = animType;				tweenElements[base]["paused"] = false;				if(i < 1){					tweenElements[base]["callback"] = callback;				}				tweenElements[base]["extra1"] = extra1;				tweenElements[base]["extra2"] = extra2;			}		}			private static function processTweens(eventInfo:Object):void{			// get the current time			var currentTime = getTimer();			// walk through and position everything where it needs to go			for(var i in tweenElements){				var _obj = tweenElements[i]["object"];				var _prop = tweenElements[i]["prop"];				if(tweenElements[i]["paused"] == true){					var timeDiff = currentTime - _prevTime;					// push the value of the tween end and do nothing					tweenElements[i]["startTime"] += timeDiff;					tweenElements[i]["endTime"] += timeDiff;				}else if(currentTime >= tweenElements[i]["endTime"]){					tweenElements[i]["object"] [_prop] = tweenElements[i]["propDest"];					// callback function					if (tweenElements[i]["callback"] != undefined) {						tweenElements[i]["callback"].apply(tweenElements[i]["object"], null);					}					// remove the element					completeTween(tweenElements[i]["object"], tweenElements[i]["prop"], currentTime);					tweenElements.splice(i, 1);				}else if(currentTime >= tweenElements[i]["startTime"]){					// tween the element					if(tweenElements[i]["propStart"] == undefined){					   tweenElements[i]["propStart"] = tweenElements[i]["object"][_prop];					}					var nextStep = findTweenValue (tweenElements[i]["propStart"], tweenElements[i]["propDest"], tweenElements[i]["startTime"], currentTime, tweenElements[i]["endTime"], tweenElements[i]["animType"], tweenElements[i]["extra1"], tweenElements[i]["extra2"]);					tweenElements[i]["object"][_prop] = nextStep;				}			}			_prevTime = currentTime;		}				private static function completeTween(object:Object, prop:Number, time:Number){			events.dispatchEvent( new Event("tweenComplete") );		}			private static function playPause(object, prop:String="", pausedValue:Boolean=true):void{			// pauses a tween			for(var i in tweenElements){				if(tweenElements[i]["object"] == object){					if(tweenElements[i]["prop"] == prop && prop != ""){						tweenElements[i]["paused"] = pausedValue;					}else if(prop == ""){						tweenElements[i]["paused"] = pausedValue;					}				}			}		}			/**		 * Pauses all the items being tweened		 */		public static function pause():void{			for(var i in tweenElements){				tweenElements[i]["paused"] = true;			}		}			/**		 * Plays all the items being tweened		 */		public static function play():void{			for(var i in tweenElements){				tweenElements[i]["paused"] = false;			}		}			/**		 * Pauses a specific tween		 *		 * @param	object		The object referenced		 * @param	prop		The property to pause. If left blank will pause all properties of the target object.		 */		public static function pauseTween(object, prop:String):void{			 playPause(object, prop, true);		}			/**		 * Starts playing a tween again		 *		 * @param	object		The object referenced		 * @param	prop		The property to play. If left blank will play all properties of the target object.		 */		public static function playTween(object, prop:String):void{			playPause(object, prop, false);		}			/**		 * Stops a tween and clears it from the list.  Will leave the object position where it is.		 *		 * @param	object		The object referenced		 * @param	prop		The property to stop. If left blank will stop all properties of the target object.		 */		public static function stopTween(object, prop:String = ""):void{			for(var data in tweenElements){				if(tweenElements[data]["object"] == object){					trace("it's the object");					if(tweenElements[data]["prop"] == prop){						tweenElements.splice(data, 1);					}else if(prop == ""){						tweenElements.splice(data, 1);					}				}			}		}			/**		 * Stops all the tweens.		 *		 */		public static function stopAllTweens():void{			// remove all tween elements in this function			tweenElements = new Array();		}			/**		 * Gets the value of a tween.		 *		 * @param	_propStart		The starting value f the tween.		 * @param	_propDest		The destination value.		 * @param	_timeStart		The start time.		 * @param	_timeNow		The current time.		 * @param	_timeDest		The ending time.		 * @param	_animType		The transition type to use.		 * @return					The correct value.		 */		public static function findTweenValue(_propStart:Number, _propDest:Number, _timeStart:Number, _timeNow:Number, _timeDest:Number, _animType:String, _extra1:Number, _extra2:Number):Number{			var t = _timeNow - _timeStart;			// current time (frames, seconds)			var b = _propStart;			// beginning value			var c = _propDest - _propStart;			// change in value			var d = _timeDest - _timeStart;			// duration (frames, seconds)			var p = new Object();			p.amplitude = _extra1;			p.period = d*(.3*1.5);						// amplitude (optional - used only on *elastic easing)			// period (optional - used only on *elastic easing)			var s = _extra1;			// overshoot ammount (optional - used only on *back easing)			switch( _animType.toLowerCase() ){				// linear				case "linear" : return easeNone(t, b, c, d, p);				// quad				case "easeinquad" : return easeInQuad(t, b, c, d, p);				case "easeoutquad" : return easeOutQuad(t, b, c, d, p);				case "easeinoutquad" : return easeInOutQuad(t, b, c, d, p);				case "easeoutinquad" : return easeOutInQuad(t, b, c, d, p);							// cubic				case "easeincubic" : return easeInCubic(t, b, c, d, p);				case "easeoutcubic" : return easeOutCubic(t, b, c, d, p);				case "easeinoutcubic" : return easeInOutCubic(t, b, c, d, p);				case "easeoutincubic" : return easeOutInCubic(t, b, c, d, p);							// quart				case "easeinquart" : return easeInQuart(t, b, c, d, p);				case "easeoutquart" : return easeOutQuart(t, b, c, d, p);				case "easeinoutquart" : return easeInOutQuart(t, b, c, d, p);				case "easeoutinquart" : return easeOutInQuart(t, b, c, d, p);							// quint				case "easeinquint" : return easeInQuint(t, b, c, d, p);				case "easeoutquint" : return easeOutQuint(t, b, c, d, p);				case "easeinoutquint" : return easeInOutQuint(t, b, c, d, p);				case "easeoutinquint" : return easeOutInQuint(t, b, c, d, p);							// sine				case "easeinsine" : return easeInSine(t, b, c, d, p);				case "easeoutsine" : return easeOutSine(t, b, c, d, p);				case "easeinoutsine" : return easeInOutSine(t, b, c, d, p);				case "easeoutinsine" : return easeOutInSine(t, b, c, d, p);							// expo				case "easeinexpo" : return easeInExpo(t, b, c, d, p);				case "easeoutexpo" : return easeOutExpo(t, b, c, d, p);				case "easeinoutexpo" : return easeInOutExpo(t, b, c, d, p);				case "easeoutinexpo" : return easeOutInExpo(t, b, c, d, p);							// circ				case "easeincirc" : return easeInCirc(t, b, c, d, p);				case "easeoutcirc" : return easeOutCirc(t, b, c, d, p);				case "easeinoutcirc" : return easeInOutCirc(t, b, c, d, p);				case "easeoutincirc" : return easeOutInCirc(t, b, c, d, p);							// elastic				case "easeinelastic" : return easeInElastic(t, b, c, d, p);				case "easeoutelastic" : return easeOutElastic(t, b, c, d, p);				case "easeinoutelastic" : return easeInOutElastic(t, b, c, d, p);				case "easeoutinelastic" : return easeOutInElastic(t, b, c, d, p);							// back				case "easeinback" : return easeInBack(t, b, c, d, p);				case "easeoutback" : return easeOutBack(t, b, c, d, p);				case "easeinoutback" : return easeInOutBack(t, b, c, d, p);				case "easeoutinback" : return easeOutInBack(t, b, c, d, p);							// bounce				case "easeinbounce" : return easeInBounce(t, b, c, d, p);				case "easeoutbounce" : return easeOutBounce(t, b, c, d, p);				case "easeinoutbounce" : return easeInOutBounce(t, b, c, d, p);				case "easeoutinbounce" : return easeOutInBounce(t, b, c, d, p);			}			// linear if nothing else			return easeNone(t, b, c, d, p);		}				// ==================================================================================================================================		// TWEENING EQUATIONS functions -----------------------------------------------------------------------------------------------------		// (the original equations are Robert Penner's work as mentioned on the disclaimer)		private static function easeNone(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return c*t/d + b;		}		private static function easeInQuad(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return c*(t/=d)*t + b;		}		private static function easeOutQuad(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return -c *(t/=d)*(t-2) + b;		}		private static function easeInOutQuad(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if ((t/=d/2) < 1) return c/2*t*t + b;			return -c/2 * ((--t)*(t-2) - 1) + b;		}		private static function easeOutInQuad(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeOutQuad (t*2, b, c/2, d, p_params);			return easeInQuad((t*2)-d, b+c/2, c/2, d, p_params);		}		private static function easeInCubic(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return c*(t/=d)*t*t + b;		}		private static function easeOutCubic(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return c*((t=t/d-1)*t*t + 1) + b;		}		private static function easeInOutCubic(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if ((t/=d/2) < 1) return c/2*t*t*t + b;			return c/2*((t-=2)*t*t + 2) + b;		}		private static function easeOutInCubic(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeOutCubic(t*2, b, c/2, d, p_params);			return easeInCubic((t*2)-d, b+c/2, c/2, d, p_params);		}		private static function easeInQuart(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return c*(t/=d)*t*t*t + b;		}		private static function easeOutQuart(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return -c * ((t=t/d-1)*t*t*t - 1) + b;		}			private static function easeInOutQuart(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if ((t/=d/2) < 1) return c/2*t*t*t*t + b;			return -c/2 * ((t-=2)*t*t*t - 2) + b;		}			private static function easeOutInQuart(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeOutQuart (t*2, b, c/2, d, p_params);			return easeInQuart((t*2)-d, b+c/2, c/2, d, p_params);		}		private static function easeInQuint(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return c*(t/=d)*t*t*t*t + b;		}		private static function easeOutQuint(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return c*((t=t/d-1)*t*t*t*t + 1) + b;		}			private static function easeInOutQuint(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;			return c/2*((t-=2)*t*t*t*t + 2) + b;		}			private static function easeOutInQuint(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeOutQuint (t*2, b, c/2, d, p_params);			return easeInQuint((t*2)-d, b+c/2, c/2, d, p_params);		}			private static function easeInSine(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return -c * Math.cos(t/d * (Math.PI/2)) + c + b;		}		private static function easeOutSine(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return c * Math.sin(t/d * (Math.PI/2)) + b;		}		private static function easeInOutSine(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;		}			private static function easeOutInSine(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeOutSine (t*2, b, c/2, d, p_params);			return easeInSine((t*2)-d, b+c/2, c/2, d, p_params);		}			private static function easeInExpo(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b - c * 0.001;		}		private static function easeOutExpo(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return (t==d) ? b+c : c * 1.001 * (-Math.pow(2, -10 * t/d) + 1) + b;		}		private static function easeInOutExpo(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t==0) return b;			if (t==d) return b+c;			if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b - c * 0.0005;			return c/2 * 1.0005 * (-Math.pow(2, -10 * --t) + 2) + b;		}		private static function easeOutInExpo(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeOutExpo (t*2, b, c/2, d, p_params);			return easeInExpo((t*2)-d, b+c/2, c/2, d, p_params);		}		private static function easeInCirc(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;		}		private static function easeOutCirc(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return c * Math.sqrt(1 - (t=t/d-1)*t) + b;		}		private static function easeInOutCirc(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;			return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;		}		private static function easeOutInCirc(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeOutCirc (t*2, b, c/2, d, p_params);			return easeInCirc((t*2)-d, b+c/2, c/2, d, p_params);		}			private static function easeInElastic(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t==0) return b;			if ((t/=d)==1) return b+c;			var p:Number = p_params.period == undefined ? d*.3 : p_params.period;			var s:Number;			var a:Number = p_params.amplitude;			if (!a || a < Math.abs(c)) {				a = c;				s = p/4;			} else {				s = p/(2*Math.PI) * Math.asin (c/a);			}			return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;		}			private static function easeOutElastic(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t==0) return b;			if ((t/=d)==1) return b+c;			var p:Number = p_params.period == undefined ? d*.3 : p_params.period;			var s:Number;			var a:Number = p_params.amplitude;			if (!a || a < Math.abs(c)) {				a = c;				s = p/4;			} else {				s = p/(2*Math.PI) * Math.asin (c/a);			}			return (a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b);		}			private static function easeInOutElastic(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t==0) return b;			if ((t/=d/2)==2) return b+c;			var p:Number = p_params.period == undefined ? d*(.3*1.5) : p_params.period;			var s:Number;			var a:Number = p_params.amplitude;			if (!a || a < Math.abs(c)) {				a = c;				s = p/4;			} else {				s = p/(2*Math.PI) * Math.asin (c/a);			}			if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;			return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;		}		private static function easeOutInElastic(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeOutElastic (t*2, b, c/2, d, p_params);			return easeInElastic((t*2)-d, b+c/2, c/2, d, p_params);		}		private static function easeInBack(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			var s:Number = p_params.overshoot == undefined ? 1.70158 : p_params.overshoot;			return c*(t/=d)*t*((s+1)*t - s) + b;		}			private static function easeOutBack(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			var s:Number = p_params.overshoot == undefined ? 1.70158 : p_params.overshoot;			return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;		}			private static function easeInOutBack(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			var s:Number = p_params.overshoot == undefined ? 1.70158 : p_params.overshoot;			if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;			return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;		}			private static function easeOutInBack(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeOutBack (t*2, b, c/2, d, p_params);			return easeInBack((t*2)-d, b+c/2, c/2, d, p_params);		}		private static function easeInBounce(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			return c - easeOutBounce (d-t, 0, c, d, p_params) + b;		}			private static function easeOutBounce(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if ((t/=d) < (1/2.75)) {				return c*(7.5625*t*t) + b;			} else if (t < (2/2.75)) {				return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;			} else if (t < (2.5/2.75)) {				return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;			} else {				return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;			}		}		private static function easeInOutBounce(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeInBounce (t*2, 0, c, d, p_params) * .5 + b;			else return easeOutBounce (t*2-d, 0, c, d, p_params) * .5 + c*.5 + b;		}		private static function easeOutInBounce(t:Number, b:Number, c:Number, d:Number, p_params:Object = null):Number {			if (t < d/2) return easeOutBounce (t*2, b, c/2, d, p_params);			return easeInBounce((t*2)-d, b+c/2, c/2, d, p_params);		}	}			}