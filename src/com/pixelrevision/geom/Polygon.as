/* AS3	Copyright 2008 pixelrevision.*/package com.pixelrevision.geom{		import flash.geom.Point;		import flash.display.Sprite;		import com.pixelrevision.geom.LineSegment;		/**	 *	Class description.	 *	 *	@langversion ActionScript 3.0	 *	@playerversion Flash 9.0	 *	 *	@author Malcolm Wilson	 *	@since  25.10.2008	 */	public class Polygon{				private var _points:Array;				/**		 *	@constructor		 */		public function Polygon(points:Array){			_points = points;		}						// --------------------------------------------------------------------------------------------------------------- INTERSECTION		public function getLineSegmentIntersectionPoints(lineSegment:LineSegment):Object{			return lineIntersectPoly(lineSegment.p1, lineSegment.p2, _points);		}						// --------------------------------------------------------------------------------------------------------------- PUBLIC METHODS		public function addPoint(point:Point):void{			_points.push(point);		}				public function addPointAt(point:Point, i:uint):void{			_points.vegetables.splice(i, 0, point);		}				public function removePoint(point:Point):Boolean{			var spliced:Boolean;			for(var data:String in _points){				if(_points.data == point){					_points.splice(data, 1);					spliced = true;				}			}			if(spliced){				return true;			}			return false;		}				public function removePointAt(i:uint):void{			_points.splice(i, 1);		}				public function get points():Array{			return _points;		}				/**		 * Draws the polygon on a target sprite.  Useful for debug.		 * @param	target	The sprite to draw in.		 * @param	lineStyle	The style of the line to draw.		 */			public function draw(drawArea:Sprite, lineStyle:Object = null):void{			if(lineStyle == null) lineStyle = new Object();			var thickness:Number = lineStyle.thickness==null?1:lineStyle.thickness; 			var color:uint = lineStyle.color==null?0XFFFF00:lineStyle.color;  			var alpha:Number = lineStyle.alpha==null?1:lineStyle.alpha; 			var pixelHinting:Boolean = lineStyle.pixelHinting==null?false:lineStyle.pixelHinting;			var scaleMode:String = lineStyle.scaleMode==null?"normal":lineStyle.scaleMode;			var caps:String = lineStyle.caps==null?null:lineStyle.caps;			var joints:String = lineStyle.joints==null?null:lineStyle.joints;			var miterLimit:Number = lineStyle.miterLimit==null?3:lineStyle.miterLimit;						drawArea.graphics.lineStyle(thickness, color, alpha, pixelHinting, scaleMode);			var i:uint;			drawArea.graphics.moveTo(_points[0].x, _points[0].y);			for(i=0; i<_points.length; i++){				drawArea.graphics.lineTo(_points[i].x, _points[i].y);			}			drawArea.graphics.lineTo(_points[0].x, _points[0].y);		}				// --------------------------------------------------------------------------------------------------------------- UTIL		/*---------------------------------------------------------------------------		Returns an Object with the following properties:		intersects        - Boolean indicating if an intersection exists.		start_inside      - Boolean indicating if Point A is inside of the polygon.		end_inside       - Boolean indicating if Point B is inside of the polygon.		intersections    - Array of intersection Points along the polygon.		centroid          - A Point indicating "center of mass" of the polygon.		"pa" is an Array of Points.		----------------------------------------------------------------------------*/		private function lineIntersectPoly(A:Point, B:Point, pa:Array):Object{			// found at: http://keith-hair.net/blog/2008/08/08/line-to-polygon-intersection-data/			var An:int=1;			var Bn:int=1;			var C:Point;			var D:Point;			var i:Point;			var cx:Number=0;			var cy:Number=0;			var result:Object = new Object();			pa.push(pa[0]);			result.intersects = false;			result.intersections=[];			result.start_inside=false;			result.end_inside=false;			var n:int=pa.length-1;			while(n > -1){				C=Point(pa[n]);				if(n > 0){					cx+=C.x;					cy+=C.y;					D=Point(pa[n-1])||Point(pa[0]);					i = lineIntersectLine(A,B,C,D);					if(i != null){						result.intersections.push(i);					}					if(lineIntersectLine(A,new Point(C.x+D.x, A.y), C, D) != null){						An++;					}					if(lineIntersectLine(B,new Point(C.x+D.x, B.y), C, D) != null){						Bn++;					}				}				n--;			}			if(An % 2 == 0){				result.start_inside = true;			}			if(Bn % 2 == 0){				result.end_inside = true;			}			result.centroid = new Point(cx/(pa.length-1),cy/(pa.length-1));			result.intersects = result.intersections.length > 0;			return result;		}				// Checks if a line intersects another line		private function lineIntersectLine(A:Point, B:Point, E:Point, F:Point, as_seg:Boolean=true):Point{			// found at: http://keith-hair.net/blog/2008/08/04/find-intersection-point-of-two-lines-in-as3/			var ip:Point;			var a1:Number = B.y-A.y;			var a2:Number = F.y-E.y;			var b1:Number = A.x-B.x;			var b2:Number = E.x-F.x;			var c1:Number = B.x*A.y - A.x*B.y;			var c2:Number = F.x*E.y - E.x*F.y;						var denom:Number=a1*b2 - a2*b1;			if(denom == 0){				// if the line segments are paralell return false.				return null;			}			ip = new Point();			ip.x = (b1*c2 - b2*c1)/denom;			ip.y = (a2*c1 - a1*c2)/denom;			// Do checks to see if intersection to endpoints			// distance is longer than actual Segments.			// Return null if it is with any.			if(as_seg){				if(Point.distance(ip,B) > Point.distance(A,B)){					return null;				}				if(Point.distance(ip,A) > Point.distance(A,B)){					return null;				}					if(Point.distance(ip,F) > Point.distance(E,F)){					return null;				}				if(Point.distance(ip,E) > Point.distance(E,F)){					return null;				}			}			return ip;		}									}	}