package com.pixelrevision.geom{		import flash.geom.Point;	import flash.display.Sprite;		import com.pixelrevision.geom.QuadraticBezier;		public class QuadraticBezierContainer{		private var _beziers:Array;		private var _data:Array;		private var _length:Number;				/**		 * Creates a quadratic bezier container to house multiple curves		 */		public function QuadraticBezierContainer(){			_beziers = new Array();			var startPoint:QuadraticBezier = new QuadraticBezier( new Point(0, 0), new Point(20, 20), new Point(40, 0) );			_beziers.push(startPoint);			update();		}				// ---------------------------------------------------------------------------------------------------------------------------- PUBLIC METHODS				/**		 * Adds a curve to the container starting at the end of the last point		 */			public function addPoint(controlPoint:Point, endPoint:Point):uint{			var lastPoint:QuadraticBezier = _beziers[_beziers.length-1];			var newPoint:QuadraticBezier = new QuadraticBezier(lastPoint.pointB, controlPoint, endPoint);			_beziers.push(newPoint);			update();			return _beziers.length - 1;		}				/**		 * Grabs the point on the curve based on a time 0-1		 */		public function getPosition(t:Number):Point{			var i:uint = getCurrentBezier(t);			var distanceTravelled:Number = (t*_length) - _data[i].start;			var percentComplete:Number = distanceTravelled/_beziers[i].length;			return _beziers[i].getPosition(percentComplete);		}				/**		 * Grabs the rotation of the point on the line at a point in time 0-1		 */		public function getRotation(t:Number):Number{			var i:uint = getCurrentBezier(t);			var distanceTravelled:Number = (t*_length) - _data[i].start;			var percentComplete:Number = distanceTravelled/_beziers[i].length;			return _beziers[i].getRotation(percentComplete);		}				/**		 * Grabs the curve that the point is on at a point in time 0-1		 */		public function getCurrentBezier(t:Number):uint{			var i:uint;			var currentPos:Number = t*_length;			var rot:Number;			for(i=0; i<_beziers.length; i++){				if(currentPos >= _data[i].start && currentPos < _data[i].end){					return i;				}			}			return 0;		}				/**		 * The list of bezier curves.		 */		public function get beziers():Array{			return _beziers;		}		public function set beziers(value:Array):void{			_beziers = value;			update();		}				/**		 * The travel distance along the curve averaged.			 */			public function get length():Number{			return _length;		}				/**		 * Draws the curve into a target sprite.  Very useful for debugging.		 * @param	drawArea	The sprite to draw in.		 * @param	lineStyle	The style of the line to draw.		 */		public function draw(drawArea:Sprite, lineStyle:Object = null):void{			var i:uint;			for(i=0; i<_beziers.length; i++){				_beziers[i].draw(drawArea, lineStyle);			}		}				// ---------------------------------------------------------------------------------------------------------------------------- UTIL		// update the curves		public function update():void{			updateCurves();			updateLengths();		}				// forces the end points of the curves to overlap		private function updateCurves():void{			var i:uint;			for(i=1; i<_beziers.length; i++){				_beziers[i].pointA = _beziers[i-1].pointB;			}		}				private function updateLengths():void{			var i:uint;			var m:uint;			_data = new Array();			_length = 0;			for(i=0; i<_beziers.length; i++){				_data[i] = new Object();				_data[i].length = _beziers[i].length;				_data[i].start = _length;				_length += _data[i].length;				_data[i].end = _length;			}		}		}}