package com.pixelrevision.geom {		import flash.geom.Point;	import flash.display.Sprite;		public class QuadraticBezier{				private var _pointA:Point;		private var _pointB:Point;		private var _controlPoint:Point;		private var _length:Number;				/**		 * Creates a quadratic bezier curve		 * @param	pointA	The start point		 * @param	controlPoint	The control point		 * @param	pointB	The end point		 */			public function QuadraticBezier(pointA:Point, controlPoint:Point, pointB:Point){			_pointA = pointA;			_controlPoint = controlPoint;			_pointB = pointB;			update();		}				/**		 * The start point		 */		public function get pointA():Point{			return _pointA;		}		public function set pointA(value:Point):void{			_pointA = value;			update();		}				/**		 * The control point		 */		public function get controlPoint():Point{			return _controlPoint;		}		public function set controlPoint(value:Point):void{			_controlPoint = value;			update();		}				/**		 * The end point		 */		public function get pointB():Point{			return _pointB;		}		public function set pointB(value:Point):void{			_pointB = value;			update();		}				/**		 * The length of the curve.  Update by using averageLength();		 */		public function get length():Number{			return _length;		}				/**		 * Gets the position on the curve		 * @param	t	The position on the curve (0-1)		 */		public function getPosition(t:Number):Point{			return getPointsOnQuadCurve(t, _pointA, _controlPoint, _pointB);		}				/**		 * Gets the rotation on the curve		 * @param	t	The position on the curve (0-1)		 * @param	sensitivity	The amount in pixels to target for the direction		 */		public function getRotation(t:Number, sensitivity:Number=.0001):Number{			var offset:Number = 0;			var startPos:Point;			var nextPos:Point;			if(t < .5){				startPos = getPosition(t);				nextPos = getPosition(t+sensitivity);			}else{				offset = -180;				startPos = getPosition(t);				nextPos = getPosition(t-sensitivity);			}			return calcRotation(startPos.x, startPos.y, nextPos.x, nextPos.y) + offset;		}				/**		 * Will get the length of the curve.		 * @param	sensitivity	The amount of points to place on the curve to calculate its length.		 */		public function averageLength(sensitivity:uint = 100):Number{			var i:uint;			var distance:Number = 0;			for(i=0; i<sensitivity-1; i++){				var current:Point = getPosition(i/sensitivity);				var next:Point = getPosition((i+1)/sensitivity);				distance += getDistance(current.x, current.y, next.x, next.y);			}			_length = distance;			return distance;		}						/**		 * Draws the curve into a target sprite.  Very useful for debugging.		 * @param	drawArea	The sprite to draw in.		 * @param	lineStyle	The style of the line to draw.		 */			public function draw(drawArea:Sprite, lineStyle:Object = null):void{			if(lineStyle == null) lineStyle = new Object();			var thickness:Number = lineStyle.thickness==null?1:lineStyle.thickness; 			var color:uint = lineStyle.color==null?0XFFFF00:lineStyle.color;  			var alpha:Number = lineStyle.alpha==null?1:lineStyle.alpha; 			var pixelHinting:Boolean = lineStyle.pixelHinting==null?false:lineStyle.pixelHinting;			var scaleMode:String = lineStyle.scaleMode==null?"normal":lineStyle.scaleMode;			var caps:String = lineStyle.caps==null?null:lineStyle.caps;			var joints:String = lineStyle.joints==null?null:lineStyle.joints;			var miterLimit:Number = lineStyle.miterLimit==null?3:lineStyle.miterLimit;			drawArea.graphics.lineStyle(thickness, color, alpha, pixelHinting, scaleMode);			drawArea.graphics.moveTo(_pointA.x, _pointA.y);			drawArea.graphics.curveTo(_controlPoint.x, _controlPoint.y, _pointB.x, _pointB.y);		}				// updates the curve		public function update():void{			averageLength();		}				// will get the point on a curve based on time		private function getPointsOnQuadCurve(t:Number, p1:Point, p2:Point, p3:Point):Point{			var ip2:Number = 2 * ( 1 - t );			return new Point(p1.x + t*(ip2*(p2.x-p1.x) + t*(p3.x - p1.x)), p1.y + t*(ip2*(p2.y-p1.y) + t*(p3.y - p1.y)));			}		// gets the distance between 2 points		private function getDistance(x1:Number, y1:Number, x2:Number, y2:Number):Number{			return Math.sqrt(Math.pow( (x1-x2), 2) + Math.pow( (y1-y2), 2));		}		// get the rotation between 2 points		private function calcRotation(x1:Number, y1:Number, x2:Number, y2:Number):Number{			return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;		}		}}