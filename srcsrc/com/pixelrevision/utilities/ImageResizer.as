package com.pixelrevision.utilities{		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.geom.Matrix;		/**	 * @class ImageResizer	 * @description Performs common image resizing functions.	 * @author pixelrevision	 * @version 1.0	 * 	 */		public class ImageResizer{		/**		 * Scales the source clip to fit within the new image using padding. Use alignment to set how the image gets aligned within the box.		 * 		 * @param	source	The clip to resize.		 * @param	newWidth	The target width.		 * @param	newHeight	The target height.		 * @param	alignH	The alignment horizontally.  Values are "left", "center", and "right".		 * @param	alignV	The alignment horizontally.  Values are "top", "middle", and "bottom".		 * @param	backgroundColor	Background color of the bitmap. If left empty bitmap background will be transparent.		 * @return 	A Bitmap that has been resized.		 */		public static function resizeWithin(source:DisplayObject, newWidth:Number, newHeight:Number, alignH:String="center", alignV:String="middle", backgroundColor:Number=-1):Bitmap{			// create the bitmap			var transparent:Boolean = true;			if(backgroundColor == -1){				backgroundColor = 0xFFFFFF;			}else{				transparent = false;			}						var resizedBitmap:BitmapData = new BitmapData(newWidth, newHeight, transparent, backgroundColor);			var translateMatrix:Matrix = new Matrix();			// get the width to scale			var widthPercent:Number = newWidth/source.width;			// get the height to scale			var heightPercent:Number = newHeight/source.height;			if(widthPercent > heightPercent){				widthPercent = heightPercent;			}else{				heightPercent = widthPercent;			}			// scale the clip accordingly			translateMatrix.scale(widthPercent, heightPercent);						// now create an offset for the alignments			if(alignH == "left"){				translateMatrix.tx = 0;			}else if(alignH == "center"){				translateMatrix.tx = (newWidth - (widthPercent*source.width) )/2;			}else if(alignH == "right"){				translateMatrix.tx = newWidth - (widthPercent*source.width);			}						// now create an offset for the alignments			if(alignV == "top"){				translateMatrix.ty = 0;			}else if(alignV == "middle"){				translateMatrix.ty = (newHeight - (heightPercent*source.height) )/2;			}else if(alignV == "bottom"){				translateMatrix.ty = newHeight - (heightPercent*source.height);			}						// draw and return the bitmap			resizedBitmap.draw(source, translateMatrix);			return new Bitmap(resizedBitmap);		}				/**		 * Crops the source clip to fit within the new image. Use alignment to set how the image gets cropped.		 * 		 * @param	source	The clip to resize.		 * @param	newWidth	The target width.		 * @param	newHeight	The target height.		 * @param	alignH	The alignment horizontally.  Values are "left", "center", and "right".		 * @param	alignV	The alignment horizontally.  Values are "top", "middle", and "bottom".		 * @param	backgroundColor	Background color of the bitmap. If left empty bitmap background will be transparent.		 * @return 	A Bitmap that has been resized.		 */		public static function resizeCropped(source:DisplayObject, newWidth:Number, newHeight:Number, alignH:String="center", alignV:String="middle", backgroundColor:Number=-1):Bitmap{			// create the bitmap			var transparent:Boolean = true;			if(backgroundColor == -1){				backgroundColor = 0xFFFFFF;			}else{				transparent = false;			}						var resizedBitmap:BitmapData = new BitmapData(newWidth, newHeight, transparent, backgroundColor);			var translateMatrix:Matrix = new Matrix();			// get the width to scale			var widthPercent:Number = newWidth/source.width;			// get the height to scale			var heightPercent:Number = newHeight/source.height;			if(widthPercent > heightPercent){				heightPercent = widthPercent;			}else{				widthPercent = heightPercent;			}			// scale the clip accordingly			translateMatrix.scale(widthPercent, heightPercent);						// now create an offset for the alignments			if(alignH == "left"){				translateMatrix.tx = 0;			}else if(alignH == "center"){				translateMatrix.tx = (newWidth - (widthPercent*source.width) )/2;			}else if(alignH == "right"){				translateMatrix.tx = newWidth - (widthPercent*source.width);			}						// now create an offset for the alignments			if(alignV == "top"){				translateMatrix.ty = 0;			}else if(alignV == "middle"){				translateMatrix.ty = (newHeight - (heightPercent*source.height) )/2;			}else if(alignV == "bottom"){				translateMatrix.ty = newHeight - (heightPercent*source.height);			}						// draw and return the bitmap			resizedBitmap.draw(source, translateMatrix);			return new Bitmap(resizedBitmap);					}					/**		 * Stretches the source clip to fit within the new image.		 * 		 * @param	source	The clip to resize.		 * @param	newWidth	The target width.		 * @param	newHeight	The target height.		 * @param	backgroundColor	Background color of the bitmap. If left empty bitmap background will be transparent.		 * @return 	A Bitmap that has been resized.		 */		public static function resizeStretched(source:DisplayObject, newWidth:Number, newHeight:Number, backgroundColor:Number=-1):Bitmap{			// create the bitmap			var transparent:Boolean = true;			if(backgroundColor == -1){				backgroundColor = 0xFFFFFF;			}else{				transparent = false;			}						var resizedBitmap:BitmapData = new BitmapData(newWidth, newHeight, transparent, backgroundColor);			var translateMatrix:Matrix = new Matrix();						// scale the clip accordingly			translateMatrix.scale(newWidth/source.width, newHeight/source.height);						// draw and return the bitmap			resizedBitmap.draw(source, translateMatrix);			return new Bitmap(resizedBitmap);		}				/**		 * Resizes the source clip to fit within the bounds set with no extra space around the edges.		 * 		 * @param	source	The clip to resize.		 * @param	newWidth	The target width.		 * @param	newHeight	The target height.		 * @param	backgroundColor	Background color of the bitmap. If left empty bitmap background will be transparent.		 * @return 	A Bitmap that has been resized.		 */		public static function resizeBounded(source:DisplayObject, newWidth:Number, newHeight:Number, backgroundColor:Number=-1):Bitmap{			// create the bitmap			var transparent:Boolean = true;			if(backgroundColor == -1){				backgroundColor = 0xFFFFFF;			}else{				transparent = false;			}						// get the width to scale			var widthPercent:Number = newWidth/source.width;			// get the height to scale			var heightPercent:Number = newHeight/source.height;			if(widthPercent > heightPercent){				widthPercent = heightPercent;			}else{				heightPercent = widthPercent;			}						var resizedBitmap:BitmapData = new BitmapData(widthPercent * source.width, heightPercent * source.height, transparent, backgroundColor);						var translateMatrix:Matrix = new Matrix();			// scale the clip accordingly			translateMatrix.scale(widthPercent, heightPercent);						// draw and return the bitmap			resizedBitmap.draw(source, translateMatrix);			return new Bitmap(resizedBitmap);		}					}}