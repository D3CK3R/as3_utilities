package com.pixelrevision.tiler {		import com.pixelrevision.tiler.TilerSprite;		import flash.display.Sprite;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.geom.Matrix;	import flash.events.Event;	public class Map extends TilerSprite{				protected var _tiles:Array;		protected var _data:Array;				protected var _tileWidth:Number;		protected var _tileHeight:Number;				protected var _mainBitmap:BitmapData;				protected var _flagForRedraw:Boolean;				/**		 *	@constructor		 */		public function Map(tileWidth:Number, tileHeight:Number){			super();			_tiles = new Array();			_data = new Array();						_tileWidth = tileWidth;			_tileHeight = tileHeight;						_flagForRedraw = true;						_mainBitmap = new BitmapData(1, 1, true, 0x000000);						flaggedForDrawing = true;					}				// ----------------------------------------------------------------------------------------- TILE LIST				/**		 * Adds a tile to the list.		 *	@param	tile	The tile to add.		 *	@return 	The index of the tile.		 */			public function addTile(tile:Tile):uint{			return _tiles.push(tile) - 1;		}				/**		 * Removes a tile from the list.		 *	@param	tile	The tile to remove		 */		public function removeTile(tile:Tile):Boolean{			for(var data in _tiles){				if(_tiles[data] == tile){					_tiles.splice(data, 1);					return true;				}			}			return false;		}				/**		 * The tiles list.		 */			public function set tiles(value:Array):void{			_tiles = value;		}		public function get tiles():Array{			return _tiles;		}						/**		 * The tiles width.		 */			public function set tileWidth(value:Number):void{			_tileWidth = value;			flagForRedraw = true;		}		public function get tileWidth():Number{			return _tileWidth;		}				/**		 * The tiles width.		 */			public function set tileHeight(value:Number):void{			_tileHeight = value;			flagForRedraw = true;		}		public function get tileHeight():Number{			return _tileHeight;		}				// ----------------------------------------------------------------------------------------- MAP DATA				/**		 * The data for the map.		 */			public function set data(value:Array):void{			_data = value;			flagForRedraw = true;		}		public function get data():Array{			return _data;		}				// this will flag the map to be redrawn on the next frame so that any other things happening this cycle can get processed		public function set flagForRedraw(value:Boolean):void{			_flagForRedraw = value;		}		public function get flagForRedraw():Boolean{			return _flagForRedraw;		}		// redraws a specific tile		protected function redrawTile(whichTile):void{			var x:uint;			var y:uint;						for(y=0; y<_data.length; y++){				for(x=0; x<_data[y].length; x++){					var id:Number = _data[y][x];					// if the tile is the one redraw it					if(_tiles[id] == whichTile){						var offsetMatrix:Matrix = new Matrix();						offsetMatrix.ty = y * _tileHeight;						offsetMatrix.tx = x * _tileWidth;						_mainBitmap.draw(_tiles[id].content, offsetMatrix);					}				}			}		}		// forces a complete redraw of the entire map.  Pretty heavy use only when needed.		protected function completeRedraw(e:Event = null):void{			var y:uint;			var x:uint;			_mainBitmap = new BitmapData(_data[0].length * _tileWidth, _data.length * _tileHeight, true, 0x000000);						// go through and draw all of the tiles to the main bitmap			for(y=0; y<_data.length; y++){				for(x=0; x<_data[y].length; x++){					var id:int = _data[y][x];					var offsetMatrix:Matrix = new Matrix();					offsetMatrix.ty = y * _tileHeight;					offsetMatrix.tx = x * _tileWidth;					_mainBitmap.draw(_tiles[id].content, offsetMatrix);				}			}						dispatchEvent( new Event("MapFullyRedrawn") );						_flagForRedraw = false;		}				/**		 * Draws the map on a tiler instance.		 * @param	tiler	The instance to draw to.		 */		override public function draw(tiler:Tiler):void{			if(_flagForRedraw){				completeRedraw();			}			// create an offset			var offsetMatrix:Matrix = new Matrix();			offsetMatrix.tx = x-tiler.camera.x + (tiler.width/2);			offsetMatrix.ty = y-tiler.camera.y + (tiler.height/2);			// redraw the bitmap			tiler.drawBoard.draw(_mainBitmap, offsetMatrix);		}			}	}