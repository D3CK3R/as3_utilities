package com.pixelrevision.effects {		import flash.display.Sprite;	import flash.display.DisplayObject;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.filters.DisplacementMapFilter;	import flash.geom.Rectangle;		public class Spheroid extends Sprite{						private var _targetClip:DisplayObject;		private var _displaceFilter:DisplacementMapFilter;		private var _displayedBitmap:Bitmap;		private var _mask:Sprite;				/**		 *	@constructor		 */		public function Spheroid(sourceObject:DisplayObject){			super();			_targetClip = sourceObject;			createSphereMap();			render();		}						public function createSphereMap():void{						var W:Number = _targetClip.width;			var H:Number = _targetClip.height;			var displaceMap:BitmapData = new BitmapData(_targetClip.width, _targetClip.height, false);						var yr:Number;			var lat:Number;			var yd :Number;			var yc:Number;			var ew:Number;			var xr:Number;			var lap:Number;			var xc:Number;			var xd:Number;			for (var y:uint = 0; y < _targetClip.height; ++y) {				yr = y / _targetClip.height; // Ratio of the Y-coordinate for the height of the picture				lat = Math.asin(1 - yr * 2); // Latitude				yd = 0.5 - lat / Math.PI - yr; // Difference of ratio of Y-coordinate of deformation front and back				yc = Math.round(yd * 0x100) + 0x80 << 8; // Y component of map				ew = Math.cos(lat); // Length in latitude line				for (var x:uint = 0; x < _targetClip.width; ++x) {					xr = x / _targetClip.width; // Ratio in X coordinate for the width of the picture					lap = Math.acos((0.5 - xr) / ew * 2); // Longitude					if (isNaN(lap)) {						xc = xr > 0.5 ? 0xFF : 0; // X component of map					} else {						xd = lap / Math.PI - xr; // Difference of ratio in X coordinate of deformation front and back						xc = Math.round(xd * 0x100) + 0x80; // X component of map					}					displaceMap.setPixel(x, y, yc | xc);				}			}			_displaceFilter = new DisplacementMapFilter(displaceMap, null, 4, 2, W, H, "color", 0x000000);						if(_mask == null){				_mask = new Sprite();				addChild(_mask);				_mask.cacheAsBitmap = true;			}			// now the mask			_mask.graphics.clear();			_mask.graphics.beginFill(0x000000);			_mask.graphics.drawCircle(0, 0, _targetClip.width/2);			_mask.width = _targetClip.width - 2;			_mask.height = _targetClip.height - 2;			_mask.x = (_targetClip.width/2) + 1;			_mask.y = (_targetClip.height/2) + 1;		}				public function render():void{			// remove the bitmap and the mask if needed			var drawBitmap:BitmapData = new BitmapData(_targetClip.width, _targetClip.height, true, 0x000000);			drawBitmap.draw(_targetClip);			if( _displayedBitmap == null ){				_displayedBitmap = new Bitmap(drawBitmap);				_displayedBitmap.smoothing = true;				addChild(_displayedBitmap);			}else{				_displayedBitmap.bitmapData = drawBitmap;			}						_displayedBitmap.filters = [_displaceFilter];						_displayedBitmap.mask = _mask;		}				}	}