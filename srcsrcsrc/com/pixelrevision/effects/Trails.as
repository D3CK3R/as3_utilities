package com.pixelrevision.effects{		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;		public class Trails extends Sprite{				private var _alphaOffset:Number;		private var _source:DisplayObject;		private var _insertedFilters:Array;		private var _bitmap:Bitmap;				/**		 *			 */			public function Trails(source:DisplayObject, width:Number, height:Number, alphaOffset:Number=.95, pixelSnapping:String = "auto", smoothing:Boolean = true){			super();			_source = source;			_alphaOffset = alphaOffset;			var bitmapData:BitmapData;			bitmapData  = new BitmapData(width, height, true, 0X000000);			_bitmap = new Bitmap(bitmapData, pixelSnapping, smoothing);			addChild(_bitmap);		}				/**		 * Renders the trails.			 */			public function render():void{			var cTransform:ColorTransform = new ColorTransform();			cTransform.alphaMultiplier = _alphaOffset;			var rectangle:Rectangle = new Rectangle(0, 0, _bitmap.bitmapData.width, _bitmap.bitmapData.height);			_bitmap.bitmapData.colorTransform(rectangle, cTransform);			for each(var i:uint in _insertedFilters){				_bitmap.bitmapData.applyFilter(_bitmap.bitmapData, rectangle, new Point(), _insertedFilters[i]);			}			// apply the offset			var matrix:Matrix = new Matrix();			var bounds:Rectangle = _source.getBounds(this);			matrix.tx = _source.x;			matrix.ty = _source.y;			_bitmap.bitmapData.draw(_source, matrix);		}				/**		 * A list of filters that will be applied to each step of the trail.		 */			public function set insertedFilters(value:Array):void{			_insertedFilters = value;		}		public function get insertedFilters():Array{			return _insertedFilters;		}				/**		 * The bitmap for the rendering.			 */			public function get bitmap():Bitmap{			return _bitmap;		}				}}